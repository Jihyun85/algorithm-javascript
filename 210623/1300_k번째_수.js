// No.1300 K번째 수
// 세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.

// 배열 A와 B의 인덱스는 1부터 시작한다.

// 약수 중 짝이 있고 둘 다 N보다 작으면 x2
// 약수 중 혼자고 N보다 작으면 x1
// 약수지만 자신과 짝 중에 하나라도 N보다 크면 x

// 시간초과 실패코드
let [N, k] = [10000, 10000000];
let count = 0;
let num = 1;

while (count < k) {
  num++;

  for (let i = 1; i <= Math.sqrt(num); i++) {
    let pair = num / i;
    if (i === pair) {
      count++;
      continue;
    }

    if (parseInt(pair) === pair && pair <= N) {
      count += 2;
    }
  }
}

console.log(num);

// 나열해보려는 코드
// const B = [];

// let N = 32;
// for (let i = 1; i <= N; i++) {
//   for (let j = 1; j <= N; j++) {
//     B.push(i * j);
//   }
// }

// console.log(B.sort((a, b) => a - b));

// let N7 = [
//   1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 8, 8, 9, 10, 10, 12, 12, 12,
//   12, 14, 14, 15, 15, 16, 18, 18, 20, 20, 21, 21, 24, 24, 25, 28, 28, 30, 30,
//   35, 35, 36, 42, 42, 49,
// ];

// let N8 = [
//   1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 8, 8, 8, 8, 9, 10, 10, 12, 12,
//   12, 12, 14, 14, 15, 15, 16, 16, 16, 18, 18, 20, 20, 21, 21, 24, 24, 24, 24,
//   25, 28, 28, 30, 30, 32, 32, 35, 35, 36, 40, 40, 42, 42, 48, 48, 49, 56, 56,
//   64,
// ];

// let N9 = [
//   1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10,
//   12, 12, 12, 12, 14, 14, 15, 15, 16, 16, 16, 18, 18, 18, 18, 20, 20, 21, 21,
//   24, 24, 24, 24, 25, 27, 27, 28, 28, 30, 30, 32, 32, 35, 35, 36, 36, 36, 40,
//   40, 42, 42, 45, 45, 48, 48, 49, 54, 54, 56, 56, 63, 63, 64, 72, 72, 81,
// ];

// let N10 = [
//   1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10,
//   10, 10, 12, 12, 12, 12, 14, 14, 15, 15, 16, 16, 16, 18, 18, 18, 18, 20, 20,
//   20, 20, 21, 21, 24, 24, 24, 24, 25, 27, 27, 28, 28, 30, 30, 30, 30, 32, 32,
//   35, 35, 36, 36, 36, 40, 40, 40, 40, 42, 42, 45, 45, 48, 48, 49, 50, 50, 54,
//   54, 56, 56, 60, 60, 63, 63, 64, 70, 70, 72, 72, 80, 80, 81, 90, 90, 100,
// ];
